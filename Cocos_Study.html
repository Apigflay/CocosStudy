<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<!-- date 4-22 -->
	<!-- 学习Cocos Creator -->
	4-18
	几个属性面板
	1：资源管理器  assets  其实就是一个数据库
	2: 层级管理器  cavas根节点　
	3：场景编辑器
	4：控件库
	5：属性检查器  相当于css

	UI系统（上）
	1：sprite 精灵
	2: lable  文字
	3：layout 布局 相当于 flex
	4: widget 组件  定位系统

	4-19
	Design Resolution属性  Fit Height 和 Fit Width  规定了在不同尺寸如何缩放
	Anchor  属性  （1，1）右上角  （0，0）左下角
	Cocos Creator 规定一个节点具有的属性都需要写在 propertie 当中
	Cocos Creator  动作 简单来说就是 节点的位移、缩放和旋转。
	// example
 	* var actionTo = cc.moveBy(2, cc.v2(windowSize.width - 40, windowSize.height - 40));
 	Prefab（预制） 资源
 	层级管理器 中将 star 节点拖拽到 资源管理器 中的 assets 文件夹下，就生成了名叫 star 的 Prefab 资源
 	
 	创建场景
 	方法一：选择主菜单：文件/新建场景  方法二：在 资源管理器 中点击创建菜单，创建新场景
	保存场景
	方法一：使用快捷键 Ctrl + S (Windows) 或 Command + S (Mac)  方法二：选择主菜单：文件/保存场景
	
	切换场景
	在 资源管理器 中，双击需要打开的场景
	修改场景资源自动释放策略：如果项目中的场景很多，随着新场景的切换，内存占用就会不断上升。除了使用 cc.loader.release 等 API 来精确释放不使用的资源，

	图像资源（Texture）

	Texture 和 SpriteFrame 资源类型
	SpriteFrame 是核心渲染组件 Sprite 所使用的资源，设置或替换 Sprite 组件中的 spriteFrame 属性，就可以切换显示的图像。
	
	预制资源Prefab
	在场景中编辑好节点后，直接将节点从 层级管理器 拖到 资源管理器
	保存预制：在场景中修改了预制实例后，在 属性检查器 中直接点击 保存，即可保存对应的预制资源
	还原预制：在场景中修改了预制实例后，在 属性检查器 中直接点击 回退，即可将预制对象还原为资源中的状态

	图集资源 Atlas
	图集（Atlas）也称作 Sprite Sheet 是游戏开发中常见的一种美术资源 图集是通过专门的工具将多张图片合并成一张大图，并通过 plist 等格式的文件索引的资源

	推荐的图集制作软件包括：TexturePacker  Zwoptex

	自动图集资源 Auto Atlas
	自动图集资源 作为 Cocos Creator 自带的合图功能，可以将指定的一系列碎图打包成一张大图，具体作用和 Texture Packer 的功能很相近

	艺术数字资源 LabelAtlas
	艺术数字资源 是一种用户自定义的资源，它可以用来配置艺术数字字体的属性。

	动态字体 Cocos Creator 支持 TTF 格式的动态字体 bf 位图资源

	使用字体资源 使用菜单创建 Label（字体）节点
	关联字体资源 可以将您的字体资源拖拽到创建的 Label 组件中的 Font 属性栏中

	粒子资源 ParticleSystem
	导入粒子资源 将 Cocos2d 支持的粒子 .plist 文件直接放到工程资源目录下
	资源管理器 里将粒子资源直接赋给组件的 File 属性
	 plist 文件中的 blendFuncSource 属性到下面的值：
	 <key>blendFuncSource</key>
    <integer>770</integer>

    声音资源
    Web Audio
    通过 Web Audio 方式加载的声音资源，在引擎内是以一个 buffer 的形式缓存的。
	这种方式的优点是兼容性好，问题比较少。缺点是占用的内存资源过多。
	DOM Audio
	通过生成一个标准的 audio 元素来播放声音资源，缓存的就是这个 audio 元素
	使用标准的 audio 元素播放声音资源的时候，在某些浏览器上可能会遇到一些限制。比如：每次播放必须是用户操作事件内才允许播放（Web Audio 只要求第一次），且只允许播放一个声音资源等。
	如果是比较大的音频如背景音乐，建议使用 DOM Audio

	动态选择加载模式 cc.loader 进行加载。

	音频默认是使用 Web Audio 的方式加载并播放的，只有在不支持的浏览器才会使用 DOM 模式。
	cc.loader.load(cc.url.raw('resources/background.mp3'), callback);

	骨骼动画资源（Spine）
	导入骨骼动画资源
	json 骨骼数据  .png 图集纹理   .txt/.atlas 图集数据
	创建骨骼动画资源
	第一种方式：从 资源管理器 里将骨骼动画资源拖动到层级管理器中
	第二种方式：从 资源管理器 里将骨骼动画资源拖动到场景中
	第二种方式： 资源管理器 里将骨骼动画资源拖动到已创建 Spine 组件中 Skeleton Data 属性中

	为 DragonBones 组件设置图集数据：从 资源管理器 里将图集数据拖动到 DragonBones 组件的 Dragon Atlas Asset 属性中

	瓦片图资源 TiledMap
	创建瓦片图资源
	第一种方式
	第一种方式
	第一种方式 从 资源管理器 里将地图资源拖动到已创建 TiledMap 组件的 Tmx File 属性中
	
	json
	关联组件
	 // 声明
    npcList: {
        default: null,
        type: cc.JsonAsset,
    },

    // 读取
    var json = this.npcList.json;
    loadNpc(json);
	动态加载
	cc.loader.loadRes('configs/npc', function (err, jsonAsset) {
        loadNpc(jsonAsset.json);
    });

    文本资源 .txt, .plist, .xml, .json, .yaml, .ini, .csv, .md  都会导入为 cc.TextAsset


    4-22
    <div>场景制作工作流程</div>
    1. 节点和组件
    在一个节点上可以添加多个组件，来为节点添加更多功能,一个节点上只能添加一个渲染组件
    2.锚点（Anchor）
    3.
    4.
    脚本开发工作流程
    1 创建组件脚本
    2 使用 cc.Class 声明类型
    需要做类型判断时，可以用 JavaScript 原生的 instanceof： cc.log(obj instanceof Sprite);       // true
    3 使用 ctor 声明构造函数：
    var Sprite = cc.Class({
	    ctor: function () {
	        cc.log(this instanceof Sprite);    // true
	    }
	});
    4 实例方法
    var Sprite = cc.Class({
	    // 声明一个名叫 "print" 的实例方法
	    print: function () { }
	});
	5 继承
	// 父类
	var Shape = cc.Class();

	// 子类
	var Rect = cc.Class({
	    extends: Shape
	});
	6 父构造函数
	var Shape = cc.Class({
	    ctor: function () {
	        cc.log("Shape");    // 实例化时，父构造函数会自动调用，
	    }
	});

	var Rect = cc.Class({
	    extends: Shape
	});

	var Square = cc.Class({
	    extends: Rect,
	    ctor: function () {
	        cc.log("Square");   // 再调用子构造函数
	    }
	});

	var square = new Square();
	7 简单声明
	当声明的属性为基本 JavaScript 类型时，可以直接赋予默认值：
	properties: {
	  height: 20,       // number
	  type: "actor",    // string
	  loaded: false,    // boolean                
	  target: null,     // object
	}
	8 完整声明
	properties: {
	    score: {
	        default: 0,
	        displayName: "Score (player)",
	        tooltip: "The score of player",
	    }
	}
	常用参数：	default: 设置属性的默认值，这个默认值仅在组件第一次添加到节点上时才会用到
				type: 限定属性的数据类型，详见 CCClass 进阶参考：type 参数
				visible: 设为 false 则不在 属性检查器 面板中显示该属性
				serializable: 设为 false 则不序列化（保存）该属性
				displayName: 在 属性检查器 面板中显示成指定名字
				tooltip: 在 属性检查器 面板中添加属性的 Tooltip
	9 通过模块访问 module.exports  require("")
	10 创建和销毁节点
	新建节点 new cc.Node()
	克隆节点 cc.instantiate
	销毁节点 node.destroy()
	destroy 和 removeFromParent 的区别：
	调用一个节点的 removeFromParent 后，它不一定就能完全从内存中释放，因为有可能由于一些逻辑上的问题，导致程序中仍然引用到了这个对象。因此如果一个节点不再使用了，请直接调用它的 destroy 而不是 removeFromParent。destroy 不但会激活组件上的 onDestroy，还会降低内存泄露的几率，同时减轻内存泄露时的后果。
	
	11 发射事件
	emit 和 dispatchEvent
	12 节点系统事件
	Cocos Creator 支持的系统事件包含鼠标、触摸、键盘、重力传感四种
	触摸事件冒泡
	13 全局系统事件  键盘事件  设备重力传感事件
	cc.SystemEvent.EventType.KEY_DOWN (键盘按下)
	cc.SystemEvent.EventType.KEY_UP (键盘释放)
	cc.SystemEvent.EventType.DEVICEMOTION (设备重力传感)
	cc.systemEvent.on(cc.SystemEvent.EventType.KEY_UP, this.onKeyUp, this);
	14 在 Cocos Creator 中使用动作系统
	// 创建一个移动动作
	var action = cc.moveTo(2, 100, 100);
	// 执行动作
	node.runAction(action);
	// 停止一个动作
	node.stopAction(action);
	// 停止所有动作
	node.stopAllActions();

	顺序动作 cc.sequence 顺序动作可以让一系列子动作按顺序一个个执行。示例
	var seq = cc.sequence(cc.moveBy(0.5, 200, 0), cc.moveBy(0.5, -200, 0));
 	node.runAction(seq);

 	// 让节点在向上移动的同时缩放
	var spawn = cc.spawn(cc.moveBy(0.5, 0, 50), cc.scaleTo(0.5, 0.8, 1.4));
	node.runAction(spawn);

	重复动作 cc.repeat 重复动作用来多次重复一个动作。示例：
	// 让节点左右来回移动，并重复5次
	 var seq = cc.repeat(
	             cc.sequence(
	                 cc.moveBy(2, 200, 0),
	                 cc.moveBy(2, -200, 0)
	             ), 5);
	 node.runAction(seq);

	永远重复动作 cc.repeatForever

	速度动作 cc.speed

	【15】
	动作列表
	容器动作 cc.sequence spawn repeat repeatForever speed
	即时动作 cc.show hide toggleVisibility removeSelf flipX flipY place callFunc targetedAction
	时间间隔动作 cc.moveTo moveBy rotateTo rotateBy scaleTo scaleBy skewTo skewBy jumpBy jumpTo follow bezierTo bezierBy
	blink fadeTo fadeIn fadeOut tintTo tintBy delayTime reverseTime cardinalSplineTo cardinalSplineBy catmullRomTo catmullRomBy
	缓动动作 easeIn 。。。。。。easeCubicActionInOut
	【16】在 Cocos Creator 中使用缓动系统（cc.tween）
	this.node.runAction(
	    cc.sequence(
	        cc.spawn(
	            cc.moveTo(1, 100, 100),
	            cc.rotateTo(1, 360),
	        ),
	        cc.scale(1, 2)
	    )
	)

	cc.tween(this.node)
    .to(1, { position: cc.v2(100, 100), rotation: 360 })
    .to(1, { scale: 2 })
    .start()
	【17】使用计时器
	 component.schedule(function() {
	     // 这里的 this 指向 component
	     this.doSomething();
	 }, 5);

	 下面是 Component 中所有关于计时器的函数：schedule  scheduleOnce  unschedule  unscheduleAllCallbacks
	【18】脚本执行顺序
	使用统一的控制脚本来初始化其他脚本
	一般我都会有一个 Game.js 的脚本作为总的控制脚本，假如我还有 Player.js, Enemy.js, Menu.js 三个组件，那么他们的初始化过程是这样的：
	// Game.js

	const Player = require('Player');
	const Enemy = require('Enemy');
	const Menu = require('Menu');

	cc.Class({
	    extends: cc.Component,
	    properties: {
	        player: Player,
	        enemy: Enemy,
	        menu: Menu
	    },

	    onLoad: function () {
	        this.player.init();
	        this.enemy.init();
	        this.menu.init();
	    }
	});
	
	在 Update 中用自定义方法控制更新顺序
	同理如果要保证以上三个脚本的每帧更新顺序，我们也可以将分散在每个脚本里的 update 替换成自己定义的方法
	// Player.js
    updatePlayer: function (dt) {
        // do player update
    }
    然后在 Game.js 脚本的 update 里调用这些方法：
    // Game.js
    update: function (dt) {
        this.player.updatePlayer(dt);
        this.enemy.updateEnemy(dt);
        this.menu.updateMenu(dt);
    }
    设置组件执行优先级 如果以上方法还是不能提供所需的控制粒度，还可以直接设置组件的 executionOrder
    cc.Class({
    extends: cc.Component,
	    editor: {
	        executionOrder: -1
	    },

	    onLoad: function () {
	        cc.log('Player onLoad!');
	    }
	});
	【19】标准网络接口
	XMLHttpRequest：用于短连接
	WebSocket：用于长连接

	开发者可以直接使用 new XMLHttpRequest() 来创建一个连接对象，也可以通过 cc.loader.getXMLHttpRequest() 来创建，两者效果一致

	SocketIO
	【20】使用对象池
	在运行时进行节点的创建(cc.instantiate)和销毁(node.destroy)操作是非常耗费性能的，因此我们在比较复杂的场景中，通常只有在场景初始化逻辑（onLoad）中才会进行节点的创建，在切换场景时才会进行节点的销毁。

	【21】模块化脚本
	以同步的 require 方法来引用其它模块
	设置 module.exports 为导出的变量
	【22】
	【23】【24】【25】【26】【27】


</body>
</html>